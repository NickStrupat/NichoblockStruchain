using System;
using System.IO;
using System.Security.Cryptography;

namespace TheBlockchainTM
{
	public static class DigitalSignature
	{
		private static readonly ECCurve Curve = ECCurve.NamedCurves.nistP521;

		/// <summary> The length of all signatures generated by the signing methods (use it to properly size the <see cref="TryGetSignature"/> destination parameter) </summary>
		public static readonly Int32 SignatureLengthInBytes = GetSignature(Array.Empty<Byte>(), GenerateKeys()).Length;

		/// <summary> Generate a new pair of keys </summary>
		public static (Byte[] PublicKey, Byte[] PrivateKey) GenerateKeys()
		{
			ECParameters ecParameters;
			using (var ecDsa = ECDsa.Create(Curve))
				ecParameters = ecDsa.ExportParameters(includePrivateParameters: true);
			var publicKey = GetBytes(ecParameters.Q);
			var privateKey = ecParameters.D;
			return (publicKey, privateKey);
		}

		/// <summary> Sign the data with the provided public and private key pair </summary>
		public static Byte[] GetSignature(Byte[] data, (Byte[] PublicKey, Byte[] PrivateKey) keys) =>
			GetSignature(data, keys.PublicKey, keys.PrivateKey);

		/// <summary> Sign the data with the provided public and private key pair </summary>
		public static Byte[] GetSignature(Byte[] data, Byte[] publicKey, Byte[] privateKey)
		{
			if (data == null)
				throw new ArgumentNullException(nameof(data));
			if (publicKey == null)
				throw new ArgumentNullException(nameof(publicKey));
			if (privateKey == null)
				throw new ArgumentNullException(nameof(privateKey));

			var ecPoint = GetEcPoint(publicKey);
			var signingEcParameters = new ECParameters { Curve = Curve, Q = ecPoint, D = privateKey };
			signingEcParameters.Validate();
			using (var ecDsa = ECDsa.Create(signingEcParameters))
				return ecDsa.SignData(data, HashAlgorithmName.SHA256);
		}

		/// <summary> Sign the data with the provided public and private key pair </summary>
		public static Boolean TryGetSignature(ReadOnlySpan<Byte> data, Span<Byte> destination, (Byte[] PublicKey, Byte[] PrivateKey) keys, out Int32 bytesWritten) =>
			TryGetSignature(data, destination, keys.PublicKey, keys.PrivateKey, out bytesWritten);

		/// <summary> Sign the data with the provided public and private key pair </summary>
		public static Boolean TryGetSignature(ReadOnlySpan<Byte> data, Span<Byte> destination, Byte[] publicKey, Byte[] privateKey, out Int32 bytesWritten)
		{
			if (publicKey == null)
				throw new ArgumentNullException(nameof(publicKey));
			if (privateKey == null)
				throw new ArgumentNullException(nameof(privateKey));

			var ecPoint = GetEcPoint(publicKey);
			var signingEcParameters = new ECParameters { Curve = Curve, Q = ecPoint, D = privateKey };
			signingEcParameters.Validate();
			using (var ecDsa = ECDsa.Create(signingEcParameters))
				return ecDsa.TrySignData(data, destination, HashAlgorithmName.SHA256, out bytesWritten);
		}

		/// <summary> Verify that the signature of the data was created by the private key corresponding to the provided public key </summary>
		public static Boolean VerifySignature(ReadOnlySpan<Byte> data, ReadOnlySpan<Byte> signature, Byte[] publicKey)
		{
			if (publicKey == null)
				throw new ArgumentNullException(nameof(publicKey));

			var ecPoint = GetEcPoint(publicKey);
			var signingEcParameters = new ECParameters { Curve = Curve, Q = ecPoint, D = null };
			signingEcParameters.Validate();
			using (var ecDsa = ECDsa.Create(signingEcParameters))
				return ecDsa.VerifyData(data, signature, HashAlgorithmName.SHA256);
		}

		/// <summary> Serialize an <see cref="ECPoint"/> to an array of bytes </summary>
		private static Byte[] GetBytes(ECPoint ecPoint)
		{
			var bytes = new Byte[sizeof(Int32) + ecPoint.X.Length + sizeof(Int32) + ecPoint.Y.Length];
			using (var ms = new MemoryStream(bytes))
			using (var bw = new BinaryWriter(ms))
			{
				bw.Write(ecPoint.X.Length);
				bw.Write(ecPoint.X);
				bw.Write(ecPoint.Y.Length);
				bw.Write(ecPoint.Y);
			}
			return bytes;
		}

		/// <summary> Deserialize an array of bytes to an <see cref="ECPoint"/> </summary>
		private static ECPoint GetEcPoint(Byte[] bytes)
		{
			using (var ms = new MemoryStream(bytes))
			using (var br = new BinaryReader(ms))
				return new ECPoint
				{
					X = br.ReadBytes(br.ReadInt32()),
					Y = br.ReadBytes(br.ReadInt32())
				};
		}
	}
}
